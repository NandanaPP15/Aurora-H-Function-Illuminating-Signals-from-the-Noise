# -*- coding: utf-8 -*-
"""1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h1M2W16VamAE3hqoEj3zXGGdpRwDqmsl

# **GW200209_085452**
"""

# ================================
# Gravitational Wave Filtering Comparison
# Only SNR Calculation + Time-Domain Plots
# Filters: Raw, Bandpass, Matched, Notch, Wiener, Wavelet
# ================================

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt, iirnotch, correlate
from scipy.fft import fft, ifft, fftfreq
import pywt
from google.colab import files

# -----------------------------
# Upload GW Data File
# -----------------------------
print("Upload gravitational wave data file (.txt):")
uploaded = files.upload()
filename = list(uploaded.keys())[0]

# -----------------------------
# Read Data
# -----------------------------
def read_gw_data(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()
    data = np.array([float(line) for line in lines if not line.startswith('#')])
    fs = 4096  # Hz (typical for LIGO)
    duration = len(data) / fs
    t = np.linspace(0, duration, len(data))
    return t, data, fs

time, strain_data, fs = read_gw_data(filename)

# -----------------------------
# Helper Functions
# -----------------------------
def butter_bandpass(lowcut, highcut, fs, order=4):
    nyq = 0.5 * fs
    low, high = lowcut / nyq, highcut / nyq
    b, a = butter(order, [low, high], btype='band')
    return b, a

def bandpass_filter(data, lowcut, highcut, fs):
    b, a = butter_bandpass(lowcut, highcut, fs)
    return filtfilt(b, a, data)

def notch_filter(data, fs, freq, Q=30):
    b, a = iirnotch(freq, Q, fs)
    return filtfilt(b, a, data)

def wiener_filter(data, noise_std):
    data_fft = fft(data)
    power_signal = np.abs(data_fft)**2
    power_noise = noise_std**2 * len(data)
    H = power_signal / (power_signal + power_noise + 1e-10)
    filtered_fft = data_fft * H
    return np.real(ifft(filtered_fft))

def wavelet_denoise(data, wavelet='db8', level=3):
    coeffs = pywt.wavedec(data, wavelet, level=level)
    sigma = np.median(np.abs(coeffs[-1])) / 0.6745
    uthresh = sigma * np.sqrt(2 * np.log(len(data)))
    coeffs_thresh = [pywt.threshold(c, value=uthresh, mode='soft') for c in coeffs]
    return pywt.waverec(coeffs_thresh, wavelet)

def matched_filter(data, template):
    corr = correlate(data, template, mode='same')
    return corr / np.max(np.abs(corr))

def calculate_snr(signal_data, fs, noise_std=None):
    if noise_std is None:
        noise_std = np.std(signal_data[:int(fs)])  # Estimate noise from first second
    signal_power = np.mean(signal_data**2)
    noise_power = noise_std**2
    return 10 * np.log10(signal_power / noise_power)

# -----------------------------
# Apply Filters
# -----------------------------
print("Applying filters...")

bandpass_filtered = bandpass_filter(strain_data, 30, 350, fs)
notch_filtered = notch_filter(strain_data, fs, 60)
noise_std = np.std(strain_data[:int(fs)])
wiener_filtered = wiener_filter(strain_data, noise_std)
wavelet_filtered = wavelet_denoise(strain_data)

# Use bandpass output as a simple "template" for matched filter
matched_filtered = matched_filter(strain_data, bandpass_filtered)

# -----------------------------
# Calculate SNR Values
# -----------------------------
print("\nCalculating SNR values...")

snr_results = {
    'Raw': calculate_snr(strain_data, fs),
    'Bandpass': calculate_snr(bandpass_filtered, fs),
    'Notch': calculate_snr(notch_filtered, fs),
    'Wiener': calculate_snr(wiener_filtered, fs),
    'Wavelet': calculate_snr(wavelet_filtered, fs),
    'Matched': calculate_snr(matched_filtered, fs),
}

for method, snr_val in snr_results.items():
    print(f"{method:<10}: {snr_val:>8.2f} dB")

# -----------------------------
# Plot Time-Domain Comparison
# -----------------------------
plt.figure(figsize=(18, 12))

plot_data = {
    'Raw': strain_data,
    'Bandpass': bandpass_filtered,
    'Matched': matched_filtered,
    'Notch': notch_filtered,
    'Wiener': wiener_filtered,
    'Wavelet': wavelet_filtered,
}

colors = ['black', 'red', 'blue', 'green', 'orange', 'purple']

for i, (name, data) in enumerate(plot_data.items()):
    plt.subplot(3, 2, i+1)
    plt.plot(time, data, color=colors[i], linewidth=0.8)
    plt.title(f"{name} Filtered Signal\nSNR: {snr_results[name]:.2f} dB")
    plt.xlabel("Time (s)")
    plt.ylabel("Strain")
    plt.grid(alpha=0.3)
    plt.xlim(0, time[-1])

plt.tight_layout()
plt.show()

# -----------------------------
# SNR Bar Chart
# -----------------------------
plt.figure(figsize=(10, 6))
methods = list(snr_results.keys())
snr_values = list(snr_results.values())

bars = plt.bar(methods, snr_values, color=colors, alpha=0.7)
plt.title("SNR Comparison of Filtering Techniques")
plt.ylabel("SNR (dB)")
plt.grid(axis='y', alpha=0.3)
plt.xticks(rotation=45)

for bar, val in zip(bars, snr_values):
    plt.text(bar.get_x() + bar.get_width()/2, val + 0.1, f"{val:.2f}", ha='center', va='bottom', fontweight='bold')

plt.tight_layout()
plt.show()

print("\n✅ SNR comparison complete.")
print(f"Best filter: {max(snr_results, key=snr_results.get)} ({max(snr_results.values()):.2f} dB)")

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.fft import fft, ifft, fftfreq
from scipy.optimize import minimize
from google.colab import files
import h5py
import io

# ----------------------------
# Load dataset
# ----------------------------
def load_data(uploaded_file):
    filename = list(uploaded_file.keys())[0]
    if filename.endswith('.hdf5') or filename.endswith('.h5'):
        with h5py.File(io.BytesIO(uploaded_file[filename]), 'r') as hdf:
            strain = hdf['strain/Strain'][:]
        time = np.arange(len(strain))
        df = pd.DataFrame({'time': time, 'strain': strain})
    elif filename.endswith('.txt') or filename.endswith('.csv'):
        df = pd.read_csv(io.BytesIO(uploaded_file[filename]),
                         comment='#', header=None).dropna()
        df.columns = ['strain']
        df['time'] = np.arange(len(df))
    else:
        raise ValueError("Unsupported file type. Upload .hdf5, .txt, or .csv")
    return df

# ----------------------------
# H-function-inspired filter
# ----------------------------
def h_filter(signal, fs, alpha, beta, gamma, delta, cutoff_freq=500):
    n = len(signal)
    freqs = fftfreq(n, 1/fs)
    fft_vals = fft(signal)
    H = 1 / (1 + (np.abs(freqs)/cutoff_freq)**alpha)**beta
    H = H * np.exp(-gamma*(np.abs(freqs)/cutoff_freq)) + delta
    H = H / np.max(H)
    filtered_fft = fft_vals * H
    filtered_signal = np.real(ifft(filtered_fft))
    return filtered_signal

# ----------------------------
# SNR calculation
# ----------------------------
def calculate_snr(signal, noise):
    signal_power = np.mean(signal**2)
    noise_power = np.mean(noise**2)
    if noise_power <= 1e-20 or np.isnan(noise_power):
        return np.nan
    return 10*np.log10(signal_power/noise_power)

# ----------------------------
# Optimize H-function parameters
# ----------------------------
def optimize_h_params(signal, fs, cutoff_freq=500, downsample=8):
    signal_ds = signal[::downsample]
    fs_ds = fs / downsample

    def objective(params):
        alpha, beta, gamma, delta = params
        if alpha<=0 or beta<=0 or gamma<0 or delta<0:
            return np.inf
        filtered = h_filter(signal_ds, fs_ds, alpha, beta, gamma, delta, cutoff_freq)
        noise = signal_ds - filtered
        snr = calculate_snr(filtered, noise)
        if np.isnan(snr):
            return np.inf
        return -snr

    bounds = [(0.1,5),(0.1,5),(0,5),(0,1)]
    initial = [1,1,0.1,0.1]
    res = minimize(objective, initial, method='L-BFGS-B', bounds=bounds)
    return res.x  # alpha, beta, gamma, delta

# ----------------------------
# Main processing
# ----------------------------
def process_uploaded_data():
    print("Upload dataset (.txt, .csv, .hdf5)")
    uploaded_file = files.upload()
    df = load_data(uploaded_file)

    fs = 4096
    signal = df['strain'].values

    # Normalize
    signal = signal - np.mean(signal)
    signal = signal / np.std(signal)

    # Optimize H-function parameters
    print("Optimizing H-function parameters...")
    alpha, beta, gamma, delta = optimize_h_params(signal, fs)
    print(f"Optimized α={alpha:.3f}, β={beta:.3f}, γ={gamma:.3f}, δ={delta:.3f}")

    # Apply H-function filter
    filtered = h_filter(signal, fs, alpha, beta, gamma, delta)
    noise = signal - filtered

    # Compute SNR
    snr = calculate_snr(filtered, noise)
    print(f"SNR after H-function filtering: {snr:.2f} dB")

    # ----------------------------
    # Plot raw vs filtered
    # ----------------------------
    plt.figure(figsize=(14,5))
    plt.plot(df['time'], signal, label='Raw Signal', alpha=0.7)
    plt.plot(df['time'], filtered, label='Filtered Signal', alpha=0.7)
    plt.title('Raw vs Filtered Signal')
    plt.xlabel('Time')
    plt.ylabel('Strain')
    plt.legend()
    plt.show()

    # Optional: plot noise separately
    plt.figure(figsize=(14,4))
    plt.plot(df['time'], noise, color='red', alpha=0.7)
    plt.title('Estimated Noise (Raw - Filtered)')
    plt.xlabel('Time')
    plt.ylabel('Noise')
    plt.show()

    return filtered, noise, snr

# ----------------------------
# Run
# ----------------------------
if __name__ == "__main__":
    process_uploaded_data()